const $ = (t) => Array.isArray(t) ? t : [t], A = (t) => Array.isArray(t) ? t.reduce((e, n) => ({ ...e, [n]: !0 }), {}) : t, v = (t, e, n, s = 0, o = 100) => (t - e) * (o - s) / (n - e) + s, x = (t, e) => Array.from(
  { length: Math.ceil(t.length / e) },
  (n, s) => t.slice(s * e, s * e + e)
), L = (...t) => t[0].map((e, n) => t.slice(1).reduce((s, o) => [...s, o[n]], [e])), E = (t) => t.length === 2 ? t : [null, ...t], C = (t) => t.reduce((e, [n, s], o) => (o === t.length - 1 ? e.push([[n, null], s]) : e.push([[n, t[o + 1][0]], s]), e), []), l = (t, e = {}) => {
  const { classes: n, styles: s, attributes: o, content: r, appendTo: c } = e, a = document.createElement(t);
  return n && $(n).forEach((i) => a.classList.add(i)), s && Object.entries(s).forEach((i) => a.style.setProperty(...i)), o && Object.entries(o).forEach(([i, p]) => {
    p || p === 0 ? a.setAttribute(i, `${p}`) : a.removeAttribute(i);
  }), r && a.append(...$(r).filter(Boolean)), c && c.appendChild(a), a;
}, y = (t, e) => {
  var o, r, c;
  const { labels: n = {}, unit: s = "" } = e || {};
  return Array.isArray(t) ? (o = n[`${t}`]) != null ? o : t[0] === null ? `< ${n[`${t[1]}`] || `${t[1]}${s}`}` : t[1] === null ? `> ${n[`${t[0]}`] || `${t[0]}${s}`}` : t.map((a) => n[`${a}`] || `${a}${s}`).join(" - ") : t !== null ? (r = n[`${t}`]) != null ? r : `${t}${s}` : (c = n.other) != null ? c : "other";
}, j = (t, e) => {
  const { inputs: n, stops: s, min: o, max: r } = t, c = s.map(([a, i]) => `${i} ${v(a, o, r)}%`);
  return l("div", {
    classes: "gradient",
    content: [
      l("p", {
        classes: "labels",
        content: n.map((a) => {
          const i = y(a, e.metadata);
          return i && l("span", {
            styles: { left: `${v(a, o, r)}%` },
            content: i
          });
        })
      }),
      l("div", {
        classes: "bar",
        styles: { "background-image": `linear-gradient(90deg, ${c})` }
      })
    ]
  });
}, B = (t, e) => {
  const { stops: n } = t;
  return l("ul", {
    classes: ["list", "list--color"],
    content: n.map(([s, o]) => {
      const r = y(s, e.metadata);
      return r && l("li", {
        styles: { "--color": o },
        content: r
      });
    })
  });
}, O = (t, e) => {
  switch (t.name) {
    case "interpolate":
      return j(t, e);
    case "match":
    case "step":
    case "literal":
      return B(t, e);
    default:
      return;
  }
}, D = (t, e) => {
  const { stops: n } = t;
  return l("ul", {
    classes: "bubbles",
    content: n.sort((s, o) => o[1] - s[1]).map(([s, o]) => {
      const r = y(s, e.metadata);
      return r && l("li", {
        styles: { "--radius": `${o}px` },
        content: l("span", {
          content: r
        })
      });
    })
  });
}, P = (t, e, n) => {
  const { stops: s } = t;
  return l("ul", {
    classes: ["list", "list--icons"],
    content: s.map(([o, r]) => {
      var g;
      const c = y(o, e.metadata);
      if (!c)
        return;
      const { height: a, width: i, data: p } = ((g = n.style.getImage(r)) == null ? void 0 : g.data) || {};
      if (!a || !i || !p)
        return;
      const d = Math.max(i, a), h = l("canvas", {
        attributes: { width: d, height: d }
      }), u = h.getContext("2d"), m = new ImageData(Uint8ClampedArray.from(p), i, a);
      return u == null || u.putImageData(m, (d - i) / 2, (d - a) / 2), l("li", {
        content: [
          l("img", {
            classes: ["icon"],
            attributes: { src: h.toDataURL() }
          }),
          c
        ]
      });
    })
  });
}, M = { color: O, radius: D, image: P, pattern: P }, f = (t, e) => x(t.slice(e), 2), b = {
  interpolate: (t) => f(t, 2),
  match: (t) => f(t, 1).map(E),
  step: (t) => C([[null, t[1]], ...f(t, 2)]),
  literal: (t) => [[...t, ...t]]
}, k = (t) => Array.isArray(t) && !!t.length && typeof t[0] == "string", S = (t) => {
  var i;
  const [e, ...n] = k(t) ? t : ["literal", t], s = (i = b[e]) == null ? void 0 : i.call(b, n);
  if (!s)
    return null;
  const [o, r] = L(...s), c = Math.min(...o.flat(2)), a = Math.max(...o.flat(2));
  return { name: e, stops: s, inputs: o, outputs: r, min: c, max: a };
}, w = { isExpression: k, parse: S }, q = {
  collapsed: !1,
  toggler: !1,
  layers: void 0
};
class R {
  constructor(e = {}) {
    const { layers: n, ...s } = e;
    this._container = l("div", {
      classes: ["mapboxgl-ctrl", "mapboxgl-ctrl-legend"]
    }), this._options = { ...q, ...s, layers: A(n) }, this._loadPanes = this._loadPanes.bind(this);
  }
  onAdd(e) {
    return this._map = e, this._map.on("styledata", this._loadPanes), this._container;
  }
  onRemove() {
    var e, n;
    (e = this._container.parentNode) == null || e.removeChild(this._container), (n = this._map) == null || n.off("styledata", this._loadPanes);
  }
  addLayers(e) {
    this._options.layers = { ...this._options.layers, ...A(e) }, this._map.isStyleLoaded() && this._loadPanes();
  }
  removeLayers(e) {
    e.forEach((n) => {
      var o;
      (o = this._options.layers) == null || delete o[n];
      const s = document.querySelector(`.mapboxgl-ctrl-legend-pane--${n}`);
      s && this._container.removeChild(s);
    });
  }
  _isAttributeVisible(e, n) {
    const { layers: s } = this._options;
    if (!s)
      return !0;
    const o = Object.keys(s).find((c) => e.match(c)), r = !!o && s[o];
    return Array.isArray(r) ? r.includes(n) : r;
  }
  _getBlock(e, n, s) {
    const [o] = n.split("-").slice(-1), r = M[o];
    if (!r)
      return;
    const c = w.parse(s);
    return c && r(c, e, this._map);
  }
  _toggleButton(e) {
    var o;
    if (!this._options.toggler)
      return;
    const n = ((o = this._map) == null ? void 0 : o.getLayoutProperty(e, "visibility")) || "visible", s = l("div", { classes: ["toggler", `toggler--${n}`] });
    return s.addEventListener("click", (r) => {
      var a, i, p;
      r.preventDefault();
      const c = n === "none" ? "visible" : "none";
      (a = this._map) == null || a.setLayoutProperty(e, "visibility", c), (p = (i = this._options).onToggle) == null || p.call(i, e, c === "visible");
    }), s;
  }
  _loadPanes() {
    const { collapsed: e, layers: n } = this._options;
    this._map.getStyle().layers.filter((s) => s.source && s.source !== "composite").filter(({ id: s }) => !n || Object.keys(n).some((o) => s.match(o))).reverse().forEach((s) => {
      const { id: o, layout: r, paint: c, metadata: a } = s, i = Object.entries({ ...r, ...c }).reduce((u, [m, g]) => {
        if (!this._isAttributeVisible(o, m))
          return u;
        const _ = this._getBlock(s, m, g);
        return _ && u.push(_), u;
      }, []);
      if (!i.length)
        return;
      const p = `mapboxgl-ctrl-legend-pane--${o}`, d = this._container.querySelector(`.${p}`), h = l("details", {
        classes: ["mapboxgl-ctrl-legend-pane", p],
        attributes: { open: d ? d.getAttribute("open") !== null : !e },
        content: [
          l("summary", { content: [(a == null ? void 0 : a.name) || o, this._toggleButton(o)] }),
          ...i
        ]
      });
      d ? this._container.replaceChild(h, d) : this._container.appendChild(h);
    });
  }
}
export {
  R as default
};
